---
phase: 01-bhxh-gateway-xml4210
plan: 03
type: execute
wave: 2
depends_on: [01-02]
files_modified:
  - backend/src/HIS.Infrastructure/Services/XmlExportService.cs
  - backend/src/HIS.Infrastructure/Services/XmlSchemaValidator.cs
  - backend/src/HIS.Infrastructure/Services/InsuranceXmlService.cs
  - backend/src/HIS.Application/Services/IInsuranceXmlService.cs
  - backend/src/HIS.Infrastructure/DependencyInjection.cs
  - backend/src/HIS.API/wwwroot/xsd/bhxh/README.txt
autonomous: true
requirements: [XML-02, XML-03]

must_haves:
  truths:
    - "ExportXmlAsync generates actual XML files with proper UTF-8 encoding and Vietnamese diacritics"
    - "All 12+ XML tables are generated as individual files even when empty (per locked decision)"
    - "XSD validation runs on all generated XML before writing to disk (per locked decision)"
    - "Missing required fields block export with a checklist of what is missing (per locked decision)"
    - "Batch export filters by date range + department only (per locked decision)"
    - "Export preview shows record counts per table, total costs, date range summary before generating files (per locked decision)"
    - "File naming follows BHXH convention: {MaCsKcb}_{period}_XML{N}.xml"
  artifacts:
    - path: "backend/src/HIS.Infrastructure/Services/XmlExportService.cs"
      provides: "XML file generation using XmlWriter with UTF-8 Vietnamese support"
      min_lines: 200
    - path: "backend/src/HIS.Infrastructure/Services/XmlSchemaValidator.cs"
      provides: "XSD schema validation service"
      min_lines: 50
    - path: "backend/src/HIS.API/wwwroot/xsd/bhxh/README.txt"
      provides: "Placeholder for XSD schema files with instructions for hospital admin"
  key_links:
    - from: "InsuranceXmlService.ExportXmlAsync"
      to: "XmlExportService"
      via: "generates XML bytes from DTO lists"
      pattern: "_xmlExportService\\.GenerateXml"
    - from: "InsuranceXmlService.ExportXmlAsync"
      to: "XmlSchemaValidator"
      via: "validates generated XML against XSD"
      pattern: "_schemaValidator\\.Validate"
    - from: "XmlExportService"
      to: "XmlWriter"
      via: "UTF8Encoding(false) streaming writer"
      pattern: "XmlWriter\\.Create.*UTF8Encoding"
---

<objective>
Build the XML file generation pipeline: XmlExportService (converts DTOs to XML files using XmlWriter), XmlSchemaValidator (validates against XSD), and rewire ExportXmlAsync to produce actual XML files with the preview-then-generate workflow.

Purpose: This is the critical path from data extraction (Plan 02) to actual XML output. Without this, the hospital cannot submit claims to BHXH. The pipeline enforces all locked decisions: block on missing data, validate against XSD, generate all 12+ tables, use UTF-8 with Vietnamese diacritics.

Output: Working XML export pipeline that generates BHXH-compliant XML files on disk
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-bhxh-gateway-xml4210/01-RESEARCH.md
@.planning/phases/01-bhxh-gateway-xml4210/01-02-SUMMARY.md

<interfaces>
<!-- All 15 XML DTOs from Plan 02 -->
From InsuranceXmlDTOs.cs:
```csharp
public class Xml1MedicalRecordDto { /* 30+ fields */ }
public class Xml2MedicineDto { /* 20+ fields */ }
public class Xml3ServiceDto { /* 20+ fields */ }
public class Xml4OtherMedicineDto { /* 12 fields */ }
public class Xml5PrescriptionDto { /* 14 fields */ }
public class Xml6BloodDto { /* 12 fields */ }
public class Xml7ReferralDto { /* 16 fields */ }
public class Xml8TransportDto { /* 9 fields */ }
public class Xml9SickLeaveDto { /* 8 fields */ }
public class Xml10AssessmentDto { /* 6 fields */ }
public class Xml11SocialInsuranceDto { /* 6 fields */ }
public class Xml13ReExamDto { /* 6 fields */ }
public class Xml14ReferralCertDto { /* 10 fields */ }
public class Xml15TbTreatmentDto { /* 7 fields */ }
```

From XmlExportConfigDto:
```csharp
public class XmlExportConfigDto { int Month, Year; DateTime? FromDate, ToDate; Guid? DepartmentId; bool IncludeXml1..15; bool ValidateBeforeExport; }
```

From XmlExportResultDto:
```csharp
public class XmlExportResultDto { Guid BatchId; string BatchCode; int TotalRecords, SuccessRecords, FailedRecords; string? FilePath; long FileSize; List<XmlExportError> Errors; DateTime ExportTime; }
```

From BhxhGatewayOptions (Plan 01):
```csharp
public class BhxhGatewayOptions { string FacilityCode; /* ... */ }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create XmlExportService and XmlSchemaValidator</name>
  <files>
    backend/src/HIS.Infrastructure/Services/XmlExportService.cs
    backend/src/HIS.Infrastructure/Services/XmlSchemaValidator.cs
    backend/src/HIS.Infrastructure/DependencyInjection.cs
    backend/src/HIS.API/wwwroot/xsd/bhxh/README.txt
  </files>
  <action>
    1. Create `XmlExportService.cs` in HIS.Infrastructure/Services:
       - Class: `XmlExportService` (no interface needed -- internal service used by InsuranceXmlService)
       - Inject: `ILogger<XmlExportService>`

       Core method pattern -- one method per XML table:
       ```csharp
       public async Task<byte[]> GenerateXml1FileAsync(List<Xml1MedicalRecordDto> records)
       ```
       Each method:
       - Creates XmlWriterSettings with `Encoding = new UTF8Encoding(false)` (UTF-8 without BOM per research)
       - Uses `MemoryStream` + `XmlWriter.Create(stream, settings)`
       - Writes XML declaration, root element per BHXH convention
       - Iterates records, writing each field as XML element using BHXH field names (uppercase: MA_LK, HO_TEN, NGAY_SINH, etc.)
       - Date format: `yyyyMMddHHmm` via `CultureInfo.InvariantCulture` (per research pitfall #2)
       - Decimal format: `Math.Round(value, 2).ToString(CultureInfo.InvariantCulture)` (per research pitfall #5)
       - Returns `stream.ToArray()` (byte[])

       Static helper for date formatting:
       ```csharp
       private static string ToBhxhDate(DateTime? dt) =>
           dt?.ToString("yyyyMMddHHmm", CultureInfo.InvariantCulture) ?? "";
       private static string ToDecimal(decimal value) =>
           Math.Round(value, 2).ToString(CultureInfo.InvariantCulture);
       ```

       XML table structure per BHXH convention:
       - XML1: root=`DSACH_THONG_TIN`, child=`THONG_TIN`, fields: MA_LK, STT, MA_BN, HO_TEN, NGAY_SINH, GIOI_TINH, DIA_CHI, MA_THE, MA_DKBD, GT_THE_TU, GT_THE_DEN, MIEN_CUNG_CT, MA_BENH_CHINH, MA_BENH_KT, MA_BENH_YHCT, MA_PTTT_QT, MA_DOI_TUONG, MA_LOAI_KCB, MA_KHOA, MA_CSKCB, MA_KHUVUC, MA_PHONG, NGAY_VAO, NGAY_RA, SO_NGAY_DTRI, KET_QUA_DTRI, TINH_TRANG_RV, T_TONGCHI, T_BHYT_TT, T_BN_CCT, T_NGUOI_BENH (group cost fields)
       - XML2: root=`DSACH_CHI_TIET_THUOC`, child=`CHI_TIET_THUOC`, fields: MA_LK, STT, MA_THUOC, MA_NHOM, TEN_THUOC, DON_VI_TINH, HAM_LUONG, DUONG_DUNG, SO_LUONG, DON_GIA, TY_LE_TT, THANH_TIEN, MA_KHOA, MA_BAC_SI, NGAY_YL, MA_PTTT, MA_BENH, T_THANH_TIEN_BV, T_BHYT, T_BNCT, T_NGUOI_BENH, MUC_HUONG, MA_NGUON_CT
       - XML3: root=`DSACH_CHI_TIET_DVKT`, child=`CHI_TIET_DVKT`, fields: similar to XML2 but MA_DVU, TEN_DVU, NGAY_KQ
       - XML4: root=`DSACH_CHI_TIET_THUOC_CT`, child=`CHI_TIET_THUOC_CT`
       - XML5: root=`DSACH_CHI_DINH_THUOC`, child=`CHI_DINH_THUOC`, fields: MA_LK, STT, MA_THUOC, TEN_THUOC, SO_DK, HAM_LUONG, SO_LUONG, DON_GIA, THANH_TIEN, LIEU_DUNG, CACH_DUNG, SO_NGAY, MA_BENH, NGAY_KE_DON
       - XML6: root=`DSACH_CHI_TIET_MAU`, child=`CHI_TIET_MAU`
       - XML7: root=`DSACH_GIAY_CHUYEN_TUYEN`, child=`GIAY_CHUYEN_TUYEN`
       - XML8: root=`DSACH_VAN_CHUYEN`, child=`VAN_CHUYEN`
       - XML9: root=`DSACH_GIAY_NGHI`, child=`GIAY_NGHI`
       - XML10: root=`DSACH_KET_QUA_GD`, child=`KET_QUA_GD`
       - XML11: root=`DSACH_SO_BHXH`, child=`SO_BHXH`
       - XML13: root=`DSACH_GIAY_HEN`, child=`GIAY_HEN`
       - XML14: root=`DSACH_PHIEU_CHUYEN_TUYEN`, child=`PHIEU_CHUYEN_TUYEN`
       - XML15: root=`DSACH_DIEU_TRI_LAO`, child=`DIEU_TRI_LAO`

       For empty tables: still generate the root element with no children (per locked decision).

    2. Create `XmlSchemaValidator.cs` in HIS.Infrastructure/Services:
       ```csharp
       public class XmlSchemaValidator
       {
           private XmlSchemaSet? _schemaSet;
           private readonly string _xsdFolderPath;
           private readonly ILogger<XmlSchemaValidator> _logger;

           public XmlSchemaValidator(string xsdFolderPath, ILogger<XmlSchemaValidator> logger)
           {
               _xsdFolderPath = xsdFolderPath;
               _logger = logger;
               ReloadSchemas();
           }

           public void ReloadSchemas()
           {
               // Load XSD files from folder, compile schema set
               // If no XSD files found, log warning and set _schemaSet = null
               // When null, Validate() returns empty list (skip validation)
           }

           public List<XmlValidationError> Validate(byte[] xmlBytes, string tableName)
           {
               // If no schemas loaded, return empty (pass) with info log
               // Use XmlReaderSettings with ValidationType.Schema
               // Collect errors via ValidationEventHandler
               // Return list of XmlValidationError (TableName, Severity, Message, LineNumber, LinePosition)
           }
       }
       ```

       Add `XmlValidationError` DTO:
       ```csharp
       public class XmlValidationError
       {
           public string TableName { get; set; } = string.Empty;
           public string Severity { get; set; } = string.Empty; // "Error" or "Warning"
           public string Message { get; set; } = string.Empty;
           public int LineNumber { get; set; }
           public int LinePosition { get; set; }
       }
       ```

    3. Register XmlExportService and XmlSchemaValidator in `DependencyInjection.cs`:
       - `services.AddSingleton<XmlExportService>();`
       - `services.AddSingleton<XmlSchemaValidator>(sp => new XmlSchemaValidator(Path.Combine(env.WebRootPath ?? "wwwroot", "xsd", "bhxh"), sp.GetRequiredService<ILogger<XmlSchemaValidator>>()));`
       - Need to pass IWebHostEnvironment or just hardcode the path relative to content root

    4. Create `wwwroot/xsd/bhxh/README.txt`:
       ```
       XSD Schema Files for BHXH XML 4210 Validation
       ================================================

       Place official BHXH XSD schema files (.xsd) in this folder.
       The system will load all .xsd files at startup for XML validation.

       To obtain XSD files:
       1. Contact your provincial BHXH office (So BHXH tinh)
       2. Request the latest XML 4210 schema per QD 4750/2024 + QD 3176/2024
       3. Place the .xsd files in this folder
       4. Restart the application or call the schema reload endpoint

       If no XSD files are present, XML validation will be skipped
       and a warning will be logged.

       Current schema version: QD 4750/2024 (amended by QD 3176/2024)
       ```
  </action>
  <verify>
    cd backend/src/HIS.API && dotnet build --no-restore 2>&1 | tail -5
    ls backend/src/HIS.API/wwwroot/xsd/bhxh/README.txt
  </verify>
  <done>
    XmlExportService generates XML bytes for all 15 tables using XmlWriter with UTF-8 (no BOM). Vietnamese diacritics preserved. BHXH date format (yyyyMMddHHmm) used. Decimal precision maintained. Empty tables produce root-element-only XML. XmlSchemaValidator loads XSD files from wwwroot/xsd/bhxh/ and validates XML against them. When no XSD files present, validation is skipped with a warning log. Both services registered in DI. README.txt instructs hospital admin how to obtain and install XSD files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewire ExportXmlAsync with preview-then-generate workflow and validation pipeline</name>
  <files>
    backend/src/HIS.Infrastructure/Services/InsuranceXmlService.cs
    backend/src/HIS.Application/Services/IInsuranceXmlService.cs
    backend/src/HIS.Application/DTOs/Insurance/InsuranceXmlDTOs.cs
    backend/src/HIS.API/Controllers/InsuranceXmlController.cs
  </files>
  <action>
    1. Add a new DTO for export preview:
       ```csharp
       public class XmlExportPreviewDto
       {
           public int TotalRecords { get; set; }
           public DateTime? DateRangeFrom { get; set; }
           public DateTime? DateRangeTo { get; set; }
           public string? DepartmentName { get; set; }
           public decimal TotalCostAmount { get; set; }
           public decimal TotalInsuranceAmount { get; set; }
           public decimal TotalPatientAmount { get; set; }
           public List<XmlTablePreview> Tables { get; set; } = new();
           public List<InsuranceValidationResultDto> ValidationErrors { get; set; } = new();
           public bool HasBlockingErrors { get; set; }
       }

       public class XmlTablePreview
       {
           public string TableName { get; set; } = string.Empty; // "XML1", "XML2", etc.
           public string Description { get; set; } = string.Empty; // Vietnamese name
           public int RecordCount { get; set; }
       }
       ```

    2. Add preview method to `IInsuranceXmlService`:
       ```csharp
       Task<XmlExportPreviewDto> PreviewExportAsync(XmlExportConfigDto config);
       ```

    3. Implement `PreviewExportAsync` in InsuranceXmlService:
       - Call all 15 GenerateXmlNDataAsync methods
       - Count records per table
       - Run ValidateBeforeExportAsync to check for missing required fields
       - If any validation errors exist, set HasBlockingErrors=true (per locked decision: block export on missing data)
       - Return XmlExportPreviewDto with counts, totals, and any blocking errors
       - This is the "table summary preview" per locked decision

    4. REWRITE `ExportXmlAsync` in InsuranceXmlService:
       - Inject `XmlExportService` and `XmlSchemaValidator` via constructor
       - Also inject `IOptions<BhxhGatewayOptions>` to get FacilityCode for file naming

       Step 1: Validate all records (blocking per locked decision)
       ```csharp
       var validationResults = await ValidateBeforeExportAsync(config);
       var blockingErrors = validationResults.Where(r => !r.IsValid).ToList();
       if (blockingErrors.Any())
       {
           return new XmlExportResultDto
           {
               BatchId = Guid.Empty,
               TotalRecords = validationResults.Count,
               FailedRecords = blockingErrors.Count,
               Errors = blockingErrors.SelectMany(r => r.Errors.Select(e => new XmlExportError
               {
                   MaLk = r.MaLk,
                   ErrorCode = e.ErrorCode,
                   ErrorMessage = e.Message
               })).ToList()
           };
       }
       ```

       Step 2: Generate all table data
       ```csharp
       var xml1Data = await GenerateXml1DataAsync(config);
       var xml2Data = await GenerateXml2DataAsync(config);
       // ... all 15 tables
       ```

       Step 3: Generate XML bytes using XmlExportService
       ```csharp
       var xml1Bytes = await _xmlExportService.GenerateXml1FileAsync(xml1Data);
       var xml2Bytes = await _xmlExportService.GenerateXml2FileAsync(xml2Data);
       // ... all 15 tables
       ```

       Step 4: XSD validation of generated XML (per locked decision)
       ```csharp
       var xsdErrors = new List<XmlValidationError>();
       xsdErrors.AddRange(_schemaValidator.Validate(xml1Bytes, "XML1"));
       xsdErrors.AddRange(_schemaValidator.Validate(xml2Bytes, "XML2"));
       // ... validate all tables

       if (xsdErrors.Any(e => e.Severity == "Error"))
       {
           return new XmlExportResultDto
           {
               Errors = xsdErrors.Select(e => new XmlExportError
               {
                   MaLk = "",
                   ErrorCode = $"XSD_{e.TableName}",
                   ErrorMessage = $"[{e.TableName}] Line {e.LineNumber}: {e.Message}"
               }).ToList()
           };
       }
       ```

       Step 5: Write files to disk with BHXH naming convention
       ```csharp
       var facilityCode = _gatewayOptions.FacilityCode;
       var period = $"{config.Year}{config.Month:D2}";
       var batchCode = $"XML-{period}-{DateTime.Now:HHmmss}";
       var outputPath = Path.Combine("exports", "xml", batchCode);
       Directory.CreateDirectory(outputPath);

       // Always write ALL tables (per locked decision), even empty ones
       await File.WriteAllBytesAsync(Path.Combine(outputPath, $"{facilityCode}_{period}_XML1.xml"), xml1Bytes);
       await File.WriteAllBytesAsync(Path.Combine(outputPath, $"{facilityCode}_{period}_XML2.xml"), xml2Bytes);
       // ... all 15 tables
       ```

       Step 6: Return success result with file path
       ```csharp
       return new XmlExportResultDto
       {
           BatchId = Guid.NewGuid(),
           BatchCode = batchCode,
           TotalRecords = xml1Data.Count,
           SuccessRecords = xml1Data.Count,
           FilePath = outputPath,
           FileSize = new DirectoryInfo(outputPath).GetFiles().Sum(f => f.Length),
           ExportTime = DateTime.Now
       };
       ```

    5. Update `DownloadXmlFileAsync`:
       - Look up batch by ID in a stored batch record (or by batch code in file system)
       - Zip all XML files in the batch folder
       - Return the zip bytes for download
       - Alternatively: store batch metadata in DB (create an XmlExportBatch entity if needed, or use the existing InsuranceSettlementBatch)

    6. Add preview endpoint to `InsuranceXmlController.cs`:
       ```csharp
       [HttpPost("xml/preview")]
       public async Task<ActionResult<XmlExportPreviewDto>> PreviewExport([FromBody] XmlExportConfigDto config)
       {
           var result = await _insuranceService.PreviewExportAsync(config);
           return Ok(result);
       }
       ```
  </action>
  <verify>
    cd backend/src/HIS.API && dotnet build --no-restore 2>&1 | tail -5
    Then test preview:
    curl -s -X POST http://localhost:5106/api/auth/login -H "Content-Type: application/json" -d '{"username":"admin","password":"Admin@123"}' | jq -r '.token' > /tmp/token.txt && curl -s -X POST http://localhost:5106/api/insurance/xml/preview -H "Authorization: Bearer $(cat /tmp/token.txt)" -H "Content-Type: application/json" -d '{"month":2,"year":2026,"validateBeforeExport":true}' | jq '.totalRecords, .tables | length, .hasBlockingErrors'
  </verify>
  <done>
    ExportXmlAsync produces actual XML files on disk with BHXH naming convention. Validation pipeline: business rules check (missing fields block export) then XSD validation. Preview endpoint returns table counts, total costs, and blocking errors before generating files. All 15 tables always generated (empty tables have root element only). File naming: {FacilityCode}_{period}_XML{N}.xml. DownloadXmlFileAsync returns the generated files. Backend builds with 0 errors.
  </done>
</task>

</tasks>

<verification>
1. Backend builds with 0 errors
2. POST /api/insurance/xml/preview returns preview with table counts
3. POST /api/insurance/xml/export generates XML files in exports/xml/{batchCode}/
4. Generated XML files have correct UTF-8 encoding (no BOM)
5. Vietnamese diacritics preserved in XML output
6. All 15 XML table files are generated (even empty ones)
7. File names follow pattern: {FacilityCode}_{period}_XML{N}.xml
8. Export blocked when required fields are missing (returns errors, no files)
</verification>

<success_criteria>
- XmlExportService generates XML bytes for all 15 tables using XmlWriter
- XmlSchemaValidator validates XML against XSD files (gracefully skips when no XSD present)
- ExportXmlAsync pipeline: validate -> generate -> XSD check -> write files
- Preview endpoint shows record counts per table, costs, blocking errors
- All locked decisions enforced: block on missing data, all 12+ tables generated, UTF-8 Vietnamese, individual files
- Batch export filters by date range + department only
</success_criteria>

<output>
After completion, create `.planning/phases/01-bhxh-gateway-xml4210/01-03-SUMMARY.md`
</output>
