---
phase: 03-security-hardening-cccd
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/HIS.API/Middleware/AuditLogMiddleware.cs
  - backend/src/HIS.Infrastructure/Services/SecurityService.cs
  - backend/src/HIS.Application/Services/ISecurityService.cs
  - backend/src/HIS.Application/DTOs/Security/SecurityComplianceDTOs.cs
  - backend/src/HIS.API/Controllers/SecurityController.cs
  - backend/src/HIS.Infrastructure/Services/SystemCompleteService.cs
  - backend/src/HIS.Infrastructure/DependencyInjection.cs
  - scripts/seed_permissions_matrix.sql
autonomous: true
requirements: [SEC-01, SEC-03]

must_haves:
  truths:
    - "GET requests to sensitive patient data endpoints are logged in the audit trail"
    - "An admin can view the access control matrix showing roles, permissions, and module access"
    - "An admin can trigger a database backup and see backup history"
    - "Database restore can be initiated from the backup history"
    - "Compliance report endpoint returns role-permission matrix data"
  artifacts:
    - path: "backend/src/HIS.Application/Services/ISecurityService.cs"
      provides: "Interface for compliance reports and backup operations"
      exports: ["ISecurityService"]
    - path: "backend/src/HIS.Infrastructure/Services/SecurityService.cs"
      provides: "Compliance report generation, real backup/restore implementation"
      min_lines: 100
    - path: "backend/src/HIS.API/Controllers/SecurityController.cs"
      provides: "Security compliance and backup endpoints"
      min_lines: 50
    - path: "backend/src/HIS.Application/DTOs/Security/SecurityComplianceDTOs.cs"
      provides: "DTOs for access control matrix, backup operations, compliance reports"
      min_lines: 40
    - path: "scripts/seed_permissions_matrix.sql"
      provides: "Standard hospital role-permission seed data per Decree 85/2016"
      contains: "INSERT INTO Permissions"
  key_links:
    - from: "backend/src/HIS.API/Middleware/AuditLogMiddleware.cs"
      to: "IAuditLogService"
      via: "Enhanced ShouldAudit to include GET for sensitive paths"
      pattern: "SensitiveGetPaths"
    - from: "backend/src/HIS.API/Controllers/SecurityController.cs"
      to: "ISecurityService"
      via: "DI injection"
      pattern: "ISecurityService"
    - from: "backend/src/HIS.Infrastructure/Services/SecurityService.cs"
      to: "HISDbContext"
      via: "EF Core queries for roles/permissions/backup"
      pattern: "Roles.*Include.*RolePermissions"
---

<objective>
Enhance audit logging for sensitive data access (SEC-01) and implement real database backup/restore (SEC-03).

Purpose: Level 6 requires tracking WHO accessed WHAT patient data and WHEN. The current audit middleware only logs POST/PUT/DELETE, missing GET requests that access sensitive patient data. The backup system is a stub returning "NotImplemented." Both are mandatory for the Level 6 certification audit.

Output: Enhanced AuditLogMiddleware with sensitive GET logging, SecurityService with compliance reports and real backup, SecurityController with endpoints, permission matrix seed data.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-hardening-cccd/03-RESEARCH.md

<interfaces>
<!-- Existing audit infrastructure the executor must enhance (not rebuild) -->

From backend/src/HIS.API/Middleware/AuditLogMiddleware.cs:
```csharp
// Current: only logs POST/PUT/DELETE, skips all GET
private static bool ShouldAudit(string path, string method)
{
    if (method.Equals("GET", StringComparison.OrdinalIgnoreCase))
        return false;  // <-- THIS IS THE GAP: sensitive GETs not logged
    // ... skip non-API paths
}
```

From backend/src/HIS.Application/Services/IAuditLogService.cs:
```csharp
public interface IAuditLogService
{
    Task LogAsync(string userId, string userName, string action,
        string entityType, string entityId, string? details,
        string? ipAddress, string? userAgent, string? module,
        string? requestPath = null, string? requestMethod = null,
        int? responseStatusCode = null);
    Task<AuditLogPagedResult> GetLogsAsync(AuditLogSearchDto dto);
    Task<List<AuditLogDto>> GetUserActivityAsync(string userId, DateTime from, DateTime to);
}
```

From backend/src/HIS.Core/Entities/User.cs:
```csharp
public class Role : BaseEntity {
    public string RoleCode { get; set; }
    public string RoleName { get; set; }
    public string? Description { get; set; }
    public virtual ICollection<UserRole> UserRoles { get; set; }
    public virtual ICollection<RolePermission> RolePermissions { get; set; }
}
public class Permission : BaseEntity {
    public string PermissionCode { get; set; }
    public string PermissionName { get; set; }
    public string? Module { get; set; }
    public string? Description { get; set; }
    public virtual ICollection<RolePermission> RolePermissions { get; set; }
}
```

From backend/src/HIS.Application/Services/ISystemCompleteService.cs:
```csharp
// Existing backup stubs to be replaced:
Task<List<BackupHistoryDto>> GetBackupHistoryAsync(DateTime? fromDate, DateTime? toDate);
Task<BackupHistoryDto> CreateBackupAsync(CreateBackupDto dto);
Task<bool> RestoreBackupAsync(Guid backupId);
Task<bool> DeleteBackupAsync(Guid backupId);
```

From docker-compose.yml:
```yaml
volumes:
  - ./backup:/var/opt/mssql/backup  # Backup volume already mapped
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance audit middleware for sensitive GET logging and create SecurityService with compliance reports</name>
  <files>
    backend/src/HIS.API/Middleware/AuditLogMiddleware.cs
    backend/src/HIS.Application/Services/ISecurityService.cs
    backend/src/HIS.Application/DTOs/Security/SecurityComplianceDTOs.cs
    backend/src/HIS.Infrastructure/Services/SecurityService.cs
    backend/src/HIS.Infrastructure/DependencyInjection.cs
  </files>
  <action>
1. In `AuditLogMiddleware.cs`, enhance `ShouldAudit` to also log GET requests for sensitive paths:
   - Add a static array `SensitiveGetPaths`:
     ```
     "/api/patients/", "/api/examination/", "/api/emr/",
     "/api/inpatient/", "/api/prescription/", "/api/reception/patient"
     ```
   - Modify `ShouldAudit`: if method is GET, check if path starts with any SensitiveGetPaths entry. Only log detail-level GETs (paths with an ID segment, not bare list endpoints) to avoid audit volume explosion.
   - Heuristic: log GET if path matches a sensitive prefix AND has path segments after the prefix (e.g., `/api/patients/123` yes, `/api/patients` no). Use path.Split('/').Length > 3 as indicator.
   - Keep existing POST/PUT/DELETE logic unchanged.
   - Keep fire-and-forget pattern for audit writes.

2. Create `backend/src/HIS.Application/DTOs/Security/SecurityComplianceDTOs.cs`:
   ```csharp
   namespace HIS.Application.DTOs.Security;

   public class AccessControlMatrixDto
   {
       public string RoleCode { get; set; }
       public string RoleName { get; set; }
       public string? Description { get; set; }
       public int UserCount { get; set; }
       public List<ModulePermissionGroup> ModulePermissions { get; set; } = new();
   }

   public class ModulePermissionGroup
   {
       public string Module { get; set; }
       public List<PermissionEntry> Permissions { get; set; } = new();
   }

   public class PermissionEntry
   {
       public string PermissionCode { get; set; }
       public string PermissionName { get; set; }
       public string? Description { get; set; }
   }

   public class SensitiveDataAccessReportDto
   {
       public string UserId { get; set; }
       public string UserName { get; set; }
       public string UserFullName { get; set; }
       public int TotalAccesses { get; set; }
       public List<SensitiveAccessEntry> RecentAccesses { get; set; } = new();
   }

   public class SensitiveAccessEntry
   {
       public DateTime Timestamp { get; set; }
       public string EntityType { get; set; }
       public string EntityId { get; set; }
       public string RequestPath { get; set; }
       public string Module { get; set; }
   }

   public class ComplianceSummaryDto
   {
       public int TotalRoles { get; set; }
       public int TotalPermissions { get; set; }
       public int TotalUsers { get; set; }
       public int ActiveUsers { get; set; }
       public int UsersWithTwoFactor { get; set; }
       public bool TdeEnabled { get; set; }
       public bool ColumnEncryptionEnabled { get; set; }
       public DateTime? LastBackupDate { get; set; }
       public int AuditLogsLast30Days { get; set; }
       public int SensitiveAccessLast30Days { get; set; }
   }
   ```

3. Create `backend/src/HIS.Application/Services/ISecurityService.cs`:
   ```csharp
   namespace HIS.Application.Services;

   public interface ISecurityService
   {
       Task<List<AccessControlMatrixDto>> GetAccessControlMatrixAsync();
       Task<List<SensitiveDataAccessReportDto>> GetSensitiveDataAccessReportAsync(DateTime from, DateTime to, int limit = 50);
       Task<ComplianceSummaryDto> GetComplianceSummaryAsync();
   }
   ```

4. Create `backend/src/HIS.Infrastructure/Services/SecurityService.cs`:
   - Inject `HISDbContext` and `ILogger<SecurityService>`
   - `GetAccessControlMatrixAsync`:
     - Query Roles with Include(RolePermissions).ThenInclude(Permission)
     - For each role, count users via UserRoles
     - Group permissions by Module
     - Return as List<AccessControlMatrixDto>
   - `GetSensitiveDataAccessReportAsync`:
     - Query AuditLogs where RequestMethod == "GET" and RequestPath starts with sensitive paths
     - Filter by date range
     - Group by UserId, aggregate TotalAccesses, take recent N
   - `GetComplianceSummaryAsync`:
     - Count roles, permissions, users (active/total), users with 2FA enabled
     - Check TDE status: raw SQL `SELECT encryption_state FROM sys.dm_database_encryption_keys WHERE database_id = DB_ID()` (wrap in try-catch, return false if fails)
     - Get last backup date from msdb query (existing pattern in GetBackupHistoryAsync)
     - Count audit logs in last 30 days
     - Count sensitive GET accesses in last 30 days

5. Register in `DependencyInjection.cs`:
   ```csharp
   services.AddScoped<ISecurityService, SecurityService>();
   ```
  </action>
  <verify>
    <automated>cd C:/Source/HIS/backend/src/HIS.Infrastructure && dotnet build --no-restore 2>&1 | tail -5</automated>
  </verify>
  <done>
    - AuditLogMiddleware logs GET requests for sensitive patient data paths (with ID, not list)
    - ISecurityService interface created with 3 methods
    - SecurityService implements access control matrix, sensitive data access report, compliance summary
    - SecurityComplianceDTOs created with all response types
    - DI registration complete
    - Backend builds with 0 errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement real backup/restore, create SecurityController, and seed permissions</name>
  <files>
    backend/src/HIS.Infrastructure/Services/SystemCompleteService.cs
    backend/src/HIS.API/Controllers/SecurityController.cs
    scripts/seed_permissions_matrix.sql
  </files>
  <action>
1. In `SystemCompleteService.cs`, replace the `CreateBackupAsync` stub with real implementation:
   ```csharp
   public async Task<BackupHistoryDto> CreateBackupAsync(CreateBackupDto dto)
   {
       var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
       var backupName = string.IsNullOrEmpty(dto.BackupName)
           ? $"HIS_Backup_{timestamp}" : dto.BackupName;
       var backupPath = $"/var/opt/mssql/backup/{backupName}.bak";

       var sql = dto.BackupType?.ToUpper() switch
       {
           "DIFFERENTIAL" => $"BACKUP DATABASE [HIS] TO DISK = N'{backupPath}' WITH DIFFERENTIAL, COMPRESSION, STATS = 10, NAME = N'{backupName}'",
           "LOG" => $"BACKUP LOG [HIS] TO DISK = N'{backupPath}' WITH COMPRESSION, STATS = 10, NAME = N'{backupName}'",
           _ => $"BACKUP DATABASE [HIS] TO DISK = N'{backupPath}' WITH COMPRESSION, STATS = 10, NAME = N'{backupName}'"
       };

       try
       {
           await _context.Database.ExecuteSqlRawAsync(sql);
           return new BackupHistoryDto
           {
               Id = Guid.NewGuid(),
               BackupName = backupName,
               BackupType = dto.BackupType ?? "Full",
               FilePath = backupPath,
               BackupDate = DateTime.UtcNow,
               Status = "Completed",
               SizeInMB = 0 // Will be populated from file system
           };
       }
       catch (Exception ex)
       {
           _logger.LogError(ex, "Database backup failed: {BackupName}", backupName);
           return new BackupHistoryDto
           {
               Id = Guid.NewGuid(),
               BackupName = backupName,
               BackupType = dto.BackupType ?? "Full",
               BackupDate = DateTime.UtcNow,
               Status = $"Failed: {ex.Message}"
           };
       }
   }
   ```

   Also replace `RestoreBackupAsync` stub:
   ```csharp
   public async Task<bool> RestoreBackupAsync(Guid backupId)
   {
       // Get backup info from history
       var history = await GetBackupHistoryAsync();
       var backup = history.FirstOrDefault(b => b.Id == backupId);
       if (backup == null || string.IsNullOrEmpty(backup.FilePath)) return false;

       try
       {
           // NOTE: RESTORE requires exclusive access — set DB to single-user first
           // This is a dangerous operation and should only be done by admin
           var sql = $@"
               ALTER DATABASE [HIS] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
               RESTORE DATABASE [HIS] FROM DISK = N'{backup.FilePath}' WITH REPLACE;
               ALTER DATABASE [HIS] SET MULTI_USER;";
           await _context.Database.ExecuteSqlRawAsync(sql);
           return true;
       }
       catch (Exception ex)
       {
           _logger.LogError(ex, "Database restore failed for backup {BackupId}", backupId);
           // Try to set back to multi-user if restore failed
           try { await _context.Database.ExecuteSqlRawAsync("ALTER DATABASE [HIS] SET MULTI_USER;"); }
           catch { /* ignore */ }
           return false;
       }
   }
   ```

2. Create `backend/src/HIS.API/Controllers/SecurityController.cs`:
   ```csharp
   [ApiController]
   [Route("api/[controller]")]
   [Authorize(Roles = "Admin")]
   public class SecurityController : ControllerBase
   {
       private readonly ISecurityService _securityService;

       // GET /api/security/compliance/access-matrix
       [HttpGet("compliance/access-matrix")]
       // Returns List<AccessControlMatrixDto>

       // GET /api/security/compliance/sensitive-access?from=&to=&limit=50
       [HttpGet("compliance/sensitive-access")]
       // Returns List<SensitiveDataAccessReportDto>

       // GET /api/security/compliance/summary
       [HttpGet("compliance/summary")]
       // Returns ComplianceSummaryDto
   }
   ```
   Each method delegates to ISecurityService. Simple controller with no business logic. If Authorize(Roles) is not working (no roles set up yet), use just [Authorize] instead.

3. Create `scripts/seed_permissions_matrix.sql` — standard Vietnamese hospital permission matrix:
   - 8 standard roles: Admin, BacSi (Doctor), DieuDuong (Nurse), TiepDon (Receptionist), ThuNgan (Cashier), DuocSi (Pharmacist), XetNghiem (Lab Tech), ChanDoan (Radiology Tech)
   - ~40 permissions grouped by module: Reception (4), OPD (5), IPD (5), Pharmacy (4), Billing (4), Laboratory (3), Radiology (3), EMR (4), MasterData (3), SystemAdmin (3), Reports (2)
   - INSERT into Roles, Permissions, RolePermissions tables
   - Idempotent: IF NOT EXISTS guards
   - Vietnamese names with English codes
   - Admin gets all permissions, other roles get module-specific subsets
  </action>
  <verify>
    <automated>cd C:/Source/HIS/backend/src/HIS.API && dotnet build --no-restore 2>&1 | tail -5 && test -f C:/Source/HIS/scripts/seed_permissions_matrix.sql && echo "SQL seed exists"</automated>
  </verify>
  <done>
    - CreateBackupAsync executes real BACKUP DATABASE via T-SQL (full/differential/log)
    - RestoreBackupAsync executes real RESTORE DATABASE with single-user mode
    - SecurityController exposes 3 compliance endpoints (access-matrix, sensitive-access, summary)
    - seed_permissions_matrix.sql provides 8 roles with ~40 permissions for Decree 85/2016 compliance
    - Backend builds with 0 errors
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds for HIS.API project (includes SecurityController + SecurityService)
2. AuditLogMiddleware.ShouldAudit returns true for GET /api/patients/{id} but false for GET /api/patients (list)
3. SecurityController endpoints return 401 without auth, 200 with admin auth
4. CreateBackupAsync no longer returns "NotImplemented"
5. seed_permissions_matrix.sql is syntactically valid SQL with IF NOT EXISTS guards
</verification>

<success_criteria>
- Sensitive data GET requests are audited (patients, examinations, EMR, inpatient, prescriptions)
- Access control matrix endpoint returns role-permission data grouped by module
- Database backup creates real .bak files in /var/opt/mssql/backup/
- Compliance summary shows TDE status, user counts, audit counts, last backup date
- Permission matrix seed covers 8 roles and ~40 permissions
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-hardening-cccd/03-02-SUMMARY.md`
</output>
