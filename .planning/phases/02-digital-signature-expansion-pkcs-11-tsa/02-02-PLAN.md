---
phase: 02-digital-signature-expansion-pkcs-11-tsa
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/HIS.Infrastructure/Services/PdfSignatureService.cs
  - backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj
autonomous: true
requirements:
  - SIGN-04
  - SIGN-02
  - SIGN-03

must_haves:
  truths:
    - "Signed PDFs include an embedded TSA timestamp from a configurable RFC 3161 server"
    - "Signed PDFs include OCSP revocation status embedded in the signature"
    - "Signed PDFs include CRL revocation data for offline verification"
    - "Signature has visible stamp at bottom of page showing doctor name, datetime, cert serial"
    - "Prescriptions, lab results, discharge papers, and referral letters can be signed through the same pipeline"
    - "Estimated signature container size is 15000+ bytes to accommodate TSA+OCSP+CRL data"
  artifacts:
    - path: "backend/src/HIS.Infrastructure/Services/PdfSignatureService.cs"
      provides: "Extended PDF signing with PKCS#11 + TSA + OCSP + CRL + visible stamp"
      contains: "SignPdfWithPkcs11Async"
    - path: "backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj"
      provides: "itext7.pdfhtml package for HTML-to-PDF conversion"
      contains: "itext7.pdfhtml"
  key_links:
    - from: "PdfSignatureService.SignPdfWithPkcs11Async"
      to: "Pkcs11ExternalSignature"
      via: "IExternalSignature parameter in PdfSigner.SignDetached"
      pattern: "signer.SignDetached"
    - from: "PdfSignatureService.SignPdfWithPkcs11Async"
      to: "TSAClientBouncyCastle"
      via: "TSA client passed to SignDetached"
      pattern: "TSAClientBouncyCastle"
    - from: "PdfSignatureService.ConvertHtmlToPdfAsync"
      to: "IPdfGenerationService"
      via: "Takes HTML byte[] output and converts to PDF byte[]"
      pattern: "HtmlConverter"
---

<objective>
Extend PdfSignatureService with PKCS#11-based PDF signing including TSA timestamps, OCSP/CRL revocation checking, visible signature stamps, and HTML-to-PDF conversion for EMR forms.

Purpose: Signed PDFs must pass Adobe Reader validation with no warnings (trusted timestamp, valid revocation status, complete certificate chain). The existing 38 EMR HTML templates need a conversion step before signing. All document types (EMR, prescriptions, lab results, discharge, referral) use the same signing pipeline.
Output: `SignPdfWithPkcs11Async` method that produces properly signed PDFs with TSA+OCSP+CRL, and `ConvertHtmlToPdfAsync` for HTML-to-PDF conversion.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-CONTEXT.md
@.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-RESEARCH.md

<interfaces>
<!-- From existing PdfSignatureService.cs - being extended -->
```csharp
public interface IPdfSignatureService
{
    Task<PdfGenerationResult> GenerateRadiologyReportPdfAsync(RadiologyReportData reportData);
    Task<PdfSignatureResult> SignPdfWithUSBTokenAsync(byte[] pdfBytes, string certificateThumbprint, string reason, string location);
    Task<PdfSignatureResult> GenerateAndSignRadiologyReportAsync(RadiologyReportData reportData, string certificateThumbprint);
}

public class PdfSignatureResult
{
    public bool Success { get; set; }
    public string Message { get; set; } = "";
    public byte[]? SignedPdfBytes { get; set; }
    public string? SignedFilePath { get; set; }
    public string? SignerName { get; set; }
    public string? SignedAt { get; set; }
    public string? CertificateSerial { get; set; }
    public string? CertificateThumbprint { get; set; }
}

// Existing IExternalSignature using Windows CryptoAPI:
public class X509Certificate2Signature : IExternalSignature { ... }
```

<!-- From existing IPdfGenerationService - produces HTML byte[] -->
```csharp
public interface IPdfGenerationService
{
    Task<byte[]> GenerateEmrPdfAsync(Guid examinationId, string formType);
    Task<byte[]> GenerateMedicalRecordSummaryAsync(Guid medicalRecordId);
    Task<byte[]> GenerateTreatmentSheetAsync(Guid admissionId);
    Task<byte[]> GenerateDischargeLetterAsync(Guid admissionId);
    Task<byte[]> GeneratePrescriptionAsync(Guid prescriptionId);
    Task<byte[]> GenerateLabResultAsync(Guid labRequestId);
}
// Note: Returns UTF-8 encoded HTML string as byte[], NOT PDF bytes.
// A conversion step (HTML -> PDF) is needed before signing.
```

<!-- From Plan 02-01 (parallel, same wave but separate concern) -->
```csharp
// Pkcs11ExternalSignature : IExternalSignature (created in Plan 01)
// Takes Pkcs11X509Certificate, delegates signing to token via Pkcs11RsaProvider

// Pkcs11Configuration (created in Plan 01)
// Has TsaUrls, EnableOcsp, EnableCrl, SignatureAppearance settings
```

<!-- iText7 packages already installed -->
```xml
<PackageReference Include="itext7" Version="8.0.2" />
<PackageReference Include="itext7.bouncy-castle-adapter" Version="8.0.2" />
<!-- Need to add: itext7.pdfhtml for HTML-to-PDF conversion -->
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add itext7.pdfhtml package and extend PdfSignatureService with PKCS#11 signing + TSA + OCSP + CRL</name>
  <files>
    backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj
    backend/src/HIS.Infrastructure/Services/PdfSignatureService.cs
  </files>
  <action>
    1. **Install itext7.pdfhtml** for HTML-to-PDF conversion:
       `cd backend/src/HIS.Infrastructure && dotnet add package itext7.pdfhtml --version 5.0.2`
       (itext7.pdfhtml 5.0.2 is compatible with itext7 8.0.2)

    2. **Extend `IPdfSignatureService` interface** with new methods (keep all existing methods for backward compat):
       ```csharp
       // NEW: Sign PDF using PKCS#11 token with TSA + OCSP + CRL
       Task<PdfSignatureResult> SignPdfWithPkcs11Async(
           byte[] pdfBytes,
           Pkcs11X509Certificate pkcs11Cert,
           Pkcs11Configuration config,
           string reason,
           string location,
           string signerName);

       // NEW: Convert HTML byte[] to PDF byte[] (for EMR form signing pipeline)
       Task<byte[]> ConvertHtmlToPdfAsync(byte[] htmlBytes);

       // NEW: Generate PDF from HTML and sign in one step
       Task<PdfSignatureResult> ConvertAndSignAsync(
           byte[] htmlBytes,
           Pkcs11X509Certificate pkcs11Cert,
           Pkcs11Configuration config,
           string reason,
           string location,
           string signerName);
       ```

    3. **Implement `SignPdfWithPkcs11Async`** (~100 lines): Core signing method with TSA + OCSP + CRL.
       - Accept `Pkcs11X509Certificate` (from Pkcs11SessionManager session entry) -- NOT a Windows certificate store thumbprint.
       - Build certificate chain for iText: Parse the X509Certificate from `pkcs11Cert.Info.ParsedCertificate.RawData` using BouncyCastle `X509CertificateParser`, wrap in `X509CertificateBC`, create `IX509Certificate[]` chain.
       - Create `Pkcs11ExternalSignature` adapter (from Plan 01) using the pkcs11Cert.
       - **TSA client setup** with fallback: Loop through `config.TsaUrls`, create `TSAClientBouncyCastle(tsaUrl)` for the first one. Wrap in try-catch; if first fails, try next. If all fail, sign without TSA (log warning, do not block signing).
       - **OCSP client**: If `config.EnableOcsp`, create `new OcspClientBouncyCastle(null)`.
       - **CRL client**: If `config.EnableCrl`, create `new List<ICrlClient> { new CrlClientOnline(chain) }`.
       - **PDF signing**: Use `PdfReader(new MemoryStream(pdfBytes))`, `PdfSigner(reader, outputStream, new StampingProperties())`.
       - **Visible signature appearance** per user decision: Stamp at bottom of LAST page (use `signer.GetDocument().GetNumberOfPages()` for page number). Rectangle per config (default 200x80 at bottom-right). Set reason, location, contact (signerName), signatureCreator "HIS Digital Signature". Show: "Ky boi: {signerName}\nNgay: {datetime}\nSo CT: {certSerial}\n{caProvider}".
       - **Field name**: `$"Sig_{DateTime.UtcNow:yyyyMMddHHmmss}_{Guid.NewGuid():N[..8]}"` (unique per signature).
       - **Estimated size**: Use 15000 (15KB) when TSA+OCSP+CRL enabled (per Pitfall 3). Use 8192 if no TSA.
       - Call `signer.SignDetached(externalSignature, chain, crlClients, ocspClient, tsaClient, estimatedSize, PdfSigner.CryptoStandard.CMS)`.
       - Return `PdfSignatureResult` with Success=true, SignedPdfBytes, SignerName, SignedAt, CertificateSerial from pkcs11Cert.

    4. **Implement `ConvertHtmlToPdfAsync`** (~30 lines): Convert HTML byte[] to PDF byte[].
       - Use `iText.Html2pdf.HtmlConverter.ConvertToPdf(htmlStream, outputStream, converterProperties)`.
       - Set `ConverterProperties` with base URI for relative resource paths if needed.
       - Set font provider to include Times New Roman (Vietnamese characters): `FontProvider` with `AddFont("C:\\Windows\\Fonts\\times.ttf")` and fallback fonts.
       - Return the PDF bytes from MemoryStream.

    5. **Implement `ConvertAndSignAsync`** (~15 lines): Convenience method that calls `ConvertHtmlToPdfAsync` then `SignPdfWithPkcs11Async`.

    6. **Update constructor** of `PdfSignatureService`: Accept `ILogger<PdfSignatureService>` (add logging throughout). Keep existing constructor logic for _fontPath and _outputFolder.

    7. **Keep ALL existing methods** (`GenerateRadiologyReportPdfAsync`, `SignPdfWithUSBTokenAsync`, `GenerateAndSignRadiologyReportAsync`, `X509Certificate2Signature` class) unchanged for backward compatibility. The new PKCS#11 methods are additions, not replacements.

    **Critical implementation notes from research pitfalls:**
    - Estimated signature size MUST be 15000+ when using TSA (Pitfall 3)
    - Build complete certificate chain including intermediate CA if available (Pitfall 5)
    - Wrap all Pkcs11 operations in try-catch for `Pkcs11Exception` with CKR_DEVICE_REMOVED detection (Pitfall 4)
    - TSA failure should NOT block signing -- degrade gracefully without timestamp
  </action>
  <verify>
    Run: `cd C:/Source/HIS/backend && dotnet build 2>&1 | tail -5`
    Expected: Build succeeded with 0 errors.
    Verify itext7.pdfhtml is in csproj: `grep -c "itext7.pdfhtml" backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj` should return 1.
  </verify>
  <done>
    PdfSignatureService extended with `SignPdfWithPkcs11Async` (TSA+OCSP+CRL), `ConvertHtmlToPdfAsync` (HTML-to-PDF), and `ConvertAndSignAsync`. Existing methods preserved. itext7.pdfhtml installed. Visible signature stamp configured. Estimated signature size set to 15000 for TSA+OCSP+CRL. Graceful fallback when TSA unavailable.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` across full backend solution succeeds with 0 errors
2. `IPdfSignatureService` has both old methods (backward compat) and new PKCS#11 methods
3. `itext7.pdfhtml` package reference exists in HIS.Infrastructure.csproj
4. `SignPdfWithPkcs11Async` uses TSAClientBouncyCastle, OcspClientBouncyCastle, CrlClientOnline
5. Estimated signature size is 15000 when TSA enabled
6. ConvertHtmlToPdfAsync uses HtmlConverter from itext7.pdfhtml
</verification>

<success_criteria>
- Backend builds with 0 errors including new itext7.pdfhtml dependency
- PdfSignatureService has SignPdfWithPkcs11Async that accepts Pkcs11X509Certificate (not thumbprint)
- TSA client configured with fallback through multiple URLs
- OCSP and CRL clients created when enabled in config
- Visible signature appearance shows signer name, datetime, cert serial, CA provider in Vietnamese
- HTML-to-PDF conversion produces valid PDF bytes from EMR HTML templates
- All existing methods preserved for backward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-02-SUMMARY.md`
</output>
