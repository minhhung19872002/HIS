---
phase: 02-digital-signature-expansion-pkcs-11-tsa
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj
  - backend/src/HIS.Core/Entities/DigitalSignature.cs
  - backend/src/HIS.Application/DTOs/DigitalSignatureDTOs.cs
  - backend/src/HIS.Infrastructure/Configuration/Pkcs11Configuration.cs
  - backend/src/HIS.Infrastructure/Services/Pkcs11SessionManager.cs
  - backend/src/HIS.Infrastructure/Services/Pkcs11ExternalSignature.cs
  - backend/src/HIS.Infrastructure/Services/TokenRegistryService.cs
  - backend/src/HIS.Infrastructure/Services/DigitalSignatureService.cs
  - backend/src/HIS.Infrastructure/Data/HISDbContext.cs
  - backend/src/HIS.Infrastructure/DependencyInjection.cs
  - backend/src/HIS.API/Controllers/DigitalSignatureController.cs
  - backend/src/HIS.API/appsettings.json
  - scripts/create_digital_signature_tables.sql
autonomous: true
requirements:
  - SIGN-01
  - SIGN-05

must_haves:
  truths:
    - "PKCS#11 session can be opened with a PIN string without triggering Windows dialog"
    - "Multiple Vietnamese CA provider DLLs are configurable via appsettings.json"
    - "Token serial number is mapped to user account on first use and auto-recognized on subsequent uses"
    - "Signing session cached for 30 minutes before requiring PIN re-entry"
    - "Certificate expiry checked before signing; expired certs blocked with Vietnamese error message"
  artifacts:
    - path: "backend/src/HIS.Core/Entities/DigitalSignature.cs"
      provides: "DocumentSignature and TokenUserMapping entities"
      contains: "class DocumentSignature"
    - path: "backend/src/HIS.Infrastructure/Services/Pkcs11SessionManager.cs"
      provides: "PKCS#11 session caching with 30-min expiry and token removal grace period"
      contains: "class Pkcs11SessionManager"
    - path: "backend/src/HIS.Infrastructure/Services/Pkcs11ExternalSignature.cs"
      provides: "IExternalSignature adapter bridging Pkcs11Interop to iText7"
      contains: "class Pkcs11ExternalSignature"
    - path: "backend/src/HIS.API/Controllers/DigitalSignatureController.cs"
      provides: "Centralized signing endpoints for all document types"
      exports: ["POST sign", "POST open-session", "GET session-status", "GET tokens", "POST register-token"]
  key_links:
    - from: "Pkcs11SessionManager"
      to: "Pkcs11Interop.X509Store"
      via: "Pkcs11X509Store with FixedPinProvider"
      pattern: "new Pkcs11X509Store"
    - from: "Pkcs11ExternalSignature"
      to: "iText7 PdfSigner"
      via: "IExternalSignature.Sign delegates to Pkcs11RsaProvider"
      pattern: "IExternalSignature"
    - from: "DigitalSignatureController"
      to: "Pkcs11SessionManager"
      via: "DI injection for session management"
      pattern: "_sessionManager"
---

<objective>
Build the core PKCS#11 signing infrastructure: entities, configuration, session management, IExternalSignature adapter, token registry, and centralized API controller.

Purpose: Replace Windows CryptoAPI (RSACng) PIN popup with programmatic PKCS#11 signing via Pkcs11Interop. This is the foundation that all other signing plans depend on.
Output: Working backend that can open a PKCS#11 session with a PIN, cache it for 30 minutes, and sign arbitrary byte[] data through a centralized API.
</objective>

<execution_context>
@C:/Users/ADMIN/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ADMIN/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-CONTEXT.md
@.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-RESEARCH.md

<interfaces>
<!-- Existing codebase contracts the executor needs -->

From backend/src/HIS.Infrastructure/Services/DigitalSignatureService.cs:
```csharp
public interface IDigitalSignatureService
{
    Task<List<CertificateInfoDto>> GetAvailableCertificatesAsync();
    Task<SignatureResultDto> SignDataAsync(byte[] data, string certificateThumbprint);
    Task<bool> VerifySignatureAsync(byte[] originalData, byte[] signature);
    Task<CertificateInfoDto> GetCertificateInfoAsync(string thumbprint);
}
```

From backend/src/HIS.Infrastructure/Services/PdfSignatureService.cs:
```csharp
public interface IPdfSignatureService
{
    Task<PdfGenerationResult> GenerateRadiologyReportPdfAsync(RadiologyReportData reportData);
    Task<PdfSignatureResult> SignPdfWithUSBTokenAsync(byte[] pdfBytes, string certificateThumbprint, string reason, string location);
    Task<PdfSignatureResult> GenerateAndSignRadiologyReportAsync(RadiologyReportData reportData, string certificateThumbprint);
}
// Existing X509Certificate2Signature : IExternalSignature (Windows CryptoAPI - being replaced)
```

From backend/src/HIS.Infrastructure/DependencyInjection.cs:
```csharp
services.AddScoped<IDigitalSignatureService, DigitalSignatureService>();
services.AddScoped<IPdfSignatureService, PdfSignatureService>();
services.AddScoped<IPdfGenerationService, PdfGenerationService>();
```

From backend/src/HIS.API/Hubs/NotificationHub.cs:
```csharp
// SignalR hub pattern already established - reuse for signing progress
[Authorize]
public class NotificationHub : Hub { ... }
// Mapped at: app.MapHub<NotificationHub>("/hubs/notifications");
```

From backend/src/HIS.API/Program.cs:
```csharp
builder.Services.AddSignalR();
// JWT auth for SignalR already configured in OnMessageReceived
```

Existing packages in HIS.Infrastructure.csproj:
```xml
<PackageReference Include="itext7" Version="8.0.2" />
<PackageReference Include="itext7.bouncy-castle-adapter" Version="8.0.2" />
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pkcs11Interop packages and create entities, DTOs, configuration</name>
  <files>
    backend/src/HIS.Infrastructure/HIS.Infrastructure.csproj
    backend/src/HIS.Core/Entities/DigitalSignature.cs
    backend/src/HIS.Application/DTOs/DigitalSignatureDTOs.cs
    backend/src/HIS.Infrastructure/Configuration/Pkcs11Configuration.cs
    backend/src/HIS.Infrastructure/Data/HISDbContext.cs
    backend/src/HIS.API/appsettings.json
    scripts/create_digital_signature_tables.sql
  </files>
  <action>
    1. **Install NuGet packages** in HIS.Infrastructure.csproj:
       - `Pkcs11Interop` version 5.3.0
       - `Pkcs11Interop.X509Store` version 1.1.0
       Run: `cd backend/src/HIS.Infrastructure && dotnet add package Pkcs11Interop --version 5.3.0 && dotnet add package Pkcs11Interop.X509Store --version 1.1.0`

    2. **Create `backend/src/HIS.Core/Entities/DigitalSignature.cs`** with TWO entities:

       **DocumentSignature** (extends BaseEntity): tracks every digital signature across all document types.
       Fields: `DocumentId` (Guid), `DocumentType` (string - "EMR", "Prescription", "LabResult", "Discharge", "Referral", "Radiology"), `DocumentCode` (string), `SignedByUserId` (Guid), `SignedAt` (DateTime), `CertificateSubject` (string), `CertificateIssuer` (string), `CertificateSerial` (string), `CertificateValidFrom` (DateTime), `CertificateValidTo` (DateTime), `CaProvider` (string - "VNPT-CA", "Viettel-CA", "BKAV-CA", "FPT-CA"), `TokenSerial` (string), `TsaTimestamp` (string? - ISO 8601), `TsaUrl` (string?), `OcspStatus` (string? - "Good", "Revoked", "Unknown"), `OcspCheckedAt` (DateTime?), `SignatureValue` (string - Base64 CMS/PKCS#7), `SignedDocumentPath` (string? - path to signed PDF on disk), `HashAlgorithm` (string, default "SHA-256"), `Status` (int - 0=Active, 1=Revoked), `RevokeReason` (string?), `RevokedAt` (DateTime?), `RevokedByUserId` (Guid?). Navigation: `virtual User SignedByUser`.

       **TokenUserMapping** (extends BaseEntity): maps physical token serial numbers to user accounts.
       Fields: `TokenSerial` (string), `TokenLabel` (string), `CaProvider` (string), `UserId` (Guid), `FirstRegisteredAt` (DateTime), `LastUsedAt` (DateTime), `IsActive` (bool, default true). Navigation: `virtual User User`.

    3. **Create `backend/src/HIS.Application/DTOs/DigitalSignatureDTOs.cs`**:
       - `OpenSessionRequest`: `string Pin` (required)
       - `OpenSessionResponse`: `bool Success`, `string? Message`, `string? TokenSerial`, `string? CaProvider`, `string? CertificateSubject`, `DateTime? SessionExpiresAt`
       - `SessionStatusResponse`: `bool Active`, `DateTime? ExpiresAt`, `string? TokenSerial`, `string? CaProvider`, `string? CertificateSubject`, `int? ExpiryWarningDays` (non-null if cert expires within 30 days)
       - `SignDocumentRequest`: `Guid DocumentId`, `string DocumentType`, `string? Pin` (optional - uses cached session if null), `string Reason`, `string Location`
       - `SignDocumentResponse`: `bool Success`, `string? Message`, `string? SignerName`, `string? SignedAt`, `string? CertificateSerial`, `string? CaProvider`, `string? TsaTimestamp`, `string? OcspStatus`, `string? SignedDocumentUrl`
       - `BatchSignRequest`: `List<Guid> DocumentIds`, `string DocumentType`, `string? Pin`, `string Reason`
       - `BatchSignResponse`: `int Total`, `int Succeeded`, `int Failed`, `List<BatchSignItemResult> Results`
       - `BatchSignItemResult`: `Guid DocumentId`, `bool Success`, `string? Error`
       - `TokenInfoDto`: `string TokenSerial`, `string TokenLabel`, `string CaProvider`, `string? MappedUserName`, `DateTime? LastUsedAt`, `bool IsActive`
       - `RegisterTokenRequest`: `string TokenSerial`
       - `DocumentSignatureDto`: `Guid Id`, `Guid DocumentId`, `string DocumentType`, `string DocumentCode`, `string SignerName`, `string SignedAt`, `string CertificateSerial`, `string CaProvider`, `string? TsaTimestamp`, `string? OcspStatus`, `int Status`

    4. **Create `backend/src/HIS.Infrastructure/Configuration/Pkcs11Configuration.cs`**:
       Strongly-typed options class bound to `appsettings.json` section "DigitalSignature".
       - `int SessionTimeoutMinutes` (default 30)
       - `int TokenRemovalGraceSeconds` (default 60)
       - `int MaxBatchSize` (default 50)
       - `string DefaultHashAlgorithm` (default "SHA-256")
       - `List<string> TsaUrls` (default: DigiCert, Sectigo)
       - `bool EnableOcsp` (default true)
       - `bool EnableCrl` (default true)
       - `Dictionary<string, CaProviderConfig> CaProviders`
       - `SignatureAppearanceConfig SignatureAppearance`

       Inner class `CaProviderConfig`: `string Pkcs11LibraryPath`, `string Label`, `string Description`
       Inner class `SignatureAppearanceConfig`: `string PagePosition` ("bottom-right"), `int Width` (200), `int Height` (80), `int FontSize` (8), `bool ShowSignerName`, `bool ShowDateTime`, `bool ShowCertificateSerial`, `bool ShowCALogo`

    5. **Update `backend/src/HIS.API/appsettings.json`**: Add the "DigitalSignature" section per the research document's configuration example. Include 4 Vietnamese CA providers (VNPT-CA, Viettel-CA, BKAV-CA, FPT-CA) with their known DLL paths. Include 3 TSA URLs as fallback (DigiCert, rfc3161.ai.moda, Sectigo).

    6. **Update `backend/src/HIS.Infrastructure/Data/HISDbContext.cs`**: Add `DbSet<DocumentSignature> DocumentSignatures` and `DbSet<TokenUserMapping> TokenUserMappings`. Add Fluent API config: DocumentSignature has index on (DocumentId, DocumentType), TokenUserMapping has unique index on TokenSerial, FK mapping for SignedByUserId and UserId.

    7. **Create `scripts/create_digital_signature_tables.sql`**: Idempotent (IF NOT EXISTS) script creating DocumentSignatures and TokenUserMappings tables matching the entity definitions. Include performance indexes.
  </action>
  <verify>
    Run: `cd C:/Source/HIS/backend/src/HIS.Infrastructure && dotnet build --no-restore 2>&1 | tail -5`
    Expected: Build succeeded with 0 errors.
    Then run the SQL script: verify it parses without errors.
  </verify>
  <done>
    Pkcs11Interop 5.3.0 and Pkcs11Interop.X509Store 1.1.0 installed. DocumentSignature + TokenUserMapping entities created with DbSet registrations. Configuration class bound to appsettings.json. DTOs cover all signing workflows. SQL tables created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Pkcs11SessionManager, Pkcs11ExternalSignature, TokenRegistryService, rewrite DigitalSignatureService, create controller</name>
  <files>
    backend/src/HIS.Infrastructure/Services/Pkcs11SessionManager.cs
    backend/src/HIS.Infrastructure/Services/Pkcs11ExternalSignature.cs
    backend/src/HIS.Infrastructure/Services/TokenRegistryService.cs
    backend/src/HIS.Infrastructure/Services/DigitalSignatureService.cs
    backend/src/HIS.Infrastructure/DependencyInjection.cs
    backend/src/HIS.API/Controllers/DigitalSignatureController.cs
  </files>
  <action>
    1. **Create `Pkcs11SessionManager.cs`** (~200 lines): Singleton service managing cached PKCS#11 sessions.
       - `ConcurrentDictionary<string, Pkcs11SessionEntry>` keyed by `"{userId}:{tokenSerial}"`
       - `Pkcs11SessionEntry`: `Pkcs11X509Store Store`, `Pkcs11X509Certificate Certificate`, `DateTime CreatedAt`, `DateTime ExpiresAt`, `string TokenSerial`, `string UserId`, `string CaProvider`, `SemaphoreSlim SigningLock` (1,1 -- serialize signing per token per Pitfall 6)
       - `GetOrCreateSessionAsync(string userId, string pin, CaProviderConfig providerConfig)`: Check cache for valid (not expired) entry for this userId. If found, return it. If not, create `FixedPinProvider` with the pin, open `new Pkcs11X509Store(providerConfig.Pkcs11LibraryPath, pinProvider)`, find first certificate with private key, extract token serial from slot info, create entry with ExpiresAt = UtcNow + SessionTimeoutMinutes, add to cache.
       - `GetActiveSessionAsync(string userId)`: Return cached session if exists and not expired, null otherwise.
       - `InvalidateSessionAsync(string userId)`: Remove and dispose session for the user.
       - `GetAllTokensAsync()`: Enumerate all configured CA providers, try to open each DLL, list slots with tokens present, return token serial + label + provider info. Wrap in try-catch per DLL (some DLLs may not exist).
       - `IDisposable`: Dispose all cached stores on shutdown.
       - Use `IOptions<Pkcs11Configuration>` for config. Use `ILogger<Pkcs11SessionManager>`.
       - **FixedPinProvider** inner class implementing `IPinProvider` (from Pkcs11Interop.X509Store) -- returns the PIN bytes for both `GetTokenPin` and `GetKeyPin`.
       - **Certificate expiry check** per user decision: Before returning session, check `Certificate.Info.ParsedCertificate.NotAfter`. If expired: throw with message "Chung chi het han ngay {date:dd/MM/yyyy}. Lien he phong CNTT." If within 30 days: log warning.
       - **SemaphoreSlim per session entry** to prevent concurrent signing on same token (Pitfall 6).

    2. **Create `Pkcs11ExternalSignature.cs`** (~50 lines): Implements `iText.Signatures.IExternalSignature`.
       - Constructor takes `Pkcs11X509Certificate certificate` and `string hashAlgorithm = "SHA-256"`.
       - `GetDigestAlgorithmName()` returns hashAlgorithm.
       - `GetSignatureAlgorithmName()` returns "RSA".
       - `GetSignatureMechanismParameters()` returns null.
       - `Sign(byte[] message)`: Get RSA private key via `_certificate.GetRSAPrivateKey()`, call `rsa.SignData(message, hashAlgName, RSASignaturePadding.Pkcs1)`. Map hash algorithm string to `HashAlgorithmName` enum. This delegates to the Pkcs11RsaProvider which sends the signing operation to the physical token without a Windows dialog.

    3. **Create `TokenRegistryService.cs`** (~120 lines): Scoped service for token-user mapping CRUD.
       - `ITokenRegistryService` interface with: `GetMappedTokenAsync(string userId)`, `RegisterTokenAsync(string userId, string tokenSerial, string tokenLabel, string caProvider)`, `GetAllTokenMappingsAsync()`, `DeactivateTokenAsync(string tokenSerial)`.
       - Implementation uses `HISDbContext` to query/save `TokenUserMapping` entities.
       - `RegisterTokenAsync`: Check if token already mapped to another user -- if so, return error. If mapped to same user, update LastUsedAt. If new, create mapping with FirstRegisteredAt = UtcNow.
       - `GetMappedTokenAsync`: Find active mapping for userId, return token info including CaProvider (used to select correct PKCS#11 DLL).

    4. **Rewrite `DigitalSignatureService.cs`**: Keep the existing interface `IDigitalSignatureService` but ADD new methods:
       - `Task<OpenSessionResponse> OpenPkcs11SessionAsync(string userId, string pin)`: Uses TokenRegistryService to find which CA provider the user's token belongs to, then calls Pkcs11SessionManager.GetOrCreateSessionAsync. If no token registered, try all configured CA providers to auto-detect (per user decision: auto-detection from token metadata). On success, auto-register the token mapping. Return session info.
       - `Task<SessionStatusResponse> GetSessionStatusAsync(string userId)`: Check if session is active, return expiry, cert info.
       - `Task<SignDocumentResponse> SignDocumentAsync(string userId, SignDocumentRequest request)`: Get active session (or open new one if Pin provided). Generate PDF bytes for the document using `IPdfGenerationService` based on DocumentType. Sign the PDF (delegate to PdfSignatureService -- extended in Plan 02). Save `DocumentSignature` entity to DB. Return result.
       - Keep existing `GetAvailableCertificatesAsync`, `SignDataAsync` (deprecated, for backward compat), `VerifySignatureAsync`, `GetCertificateInfoAsync`.

    5. **Update `DependencyInjection.cs`**:
       - Register `Pkcs11SessionManager` as **Singleton** (holds cached sessions across requests).
       - Register `ITokenRegistryService` / `TokenRegistryService` as Scoped.
       - Keep existing `IDigitalSignatureService` / `DigitalSignatureService` as Scoped.
       - Bind `Pkcs11Configuration` via `services.Configure<Pkcs11Configuration>(configuration.GetSection("DigitalSignature"))`.

    6. **Create `DigitalSignatureController.cs`** (~180 lines) at `/api/digital-signature`:
       - `POST /open-session` (body: `OpenSessionRequest`): Extract userId from JWT claims. Call `OpenPkcs11SessionAsync`. Return session info.
       - `GET /session-status`: Get current session status for authenticated user.
       - `POST /close-session`: Invalidate the current user's signing session.
       - `GET /tokens`: List all detected tokens across all configured CA providers. Admin-only.
       - `POST /register-token` (body: `RegisterTokenRequest`): Map a token serial to the authenticated user.
       - `POST /sign` (body: `SignDocumentRequest`): Sign a single document. Uses cached session or opens new with Pin.
       - `GET /signatures/{documentId}`: Get signature info for a document.
       - `GET /signatures/by-type/{documentType}`: List all signatures for a document type (paged).
       - All endpoints require `[Authorize]`. Use `[Authorize(Roles = "Admin")]` for `/tokens`.
  </action>
  <verify>
    Run: `cd C:/Source/HIS/backend && dotnet build 2>&1 | tail -5`
    Expected: Build succeeded with 0 errors across all projects (HIS.Core, HIS.Application, HIS.Infrastructure, HIS.API).
  </verify>
  <done>
    Pkcs11SessionManager caches PKCS#11 sessions for 30 minutes with per-token semaphore serialization. Pkcs11ExternalSignature bridges Pkcs11Interop to iText7. TokenRegistryService persists token-user mappings. DigitalSignatureService rewritten with PKCS#11 methods while keeping backward compatibility. Controller exposes all signing endpoints. All services registered in DI.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` across full backend solution succeeds with 0 errors
2. Pkcs11Interop and Pkcs11Interop.X509Store packages are in HIS.Infrastructure.csproj
3. DocumentSignatures and TokenUserMappings tables can be created via SQL script
4. DigitalSignatureController endpoints are reachable (even if PKCS#11 DLL not present -- should return graceful error)
5. Configuration loads from appsettings.json with 4 CA providers
</verification>

<success_criteria>
- Backend builds with 0 errors
- PKCS#11 session management code compiles against Pkcs11Interop.X509Store API
- IExternalSignature adapter compiles against iText7 API
- All 6 controller endpoints defined and reachable
- DocumentSignature and TokenUserMapping entities registered in DbContext
- Configuration strongly typed and bound from appsettings.json
</success_criteria>

<output>
After completion, create `.planning/phases/02-digital-signature-expansion-pkcs-11-tsa/02-01-SUMMARY.md`
</output>
